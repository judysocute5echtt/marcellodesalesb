---
author: mvader
date: 2017-02-27
title: "Proteus, keeping Go as the source of truth"
description: "We are releasing proteus, a tool to generate protobuf files taking Go as the source of truth instead of the other way around."
categories: ["technical"]
---

## Introduction

At source{d} we've been using Go for almost two years. Until machine learning came along, Go was the only language in which we needed to use our data models. Right now, Python is playing a bigger role in our platform and Scala is joining as another player. With that in mind, we need to start thinking how to effectively and efficiently share our data models across all those languages, and others, in case we would start using more.

We chose protocol buffers as the serialization format for this exchange of data. Usually, people create their `.proto` files where they define their models, enumerations, services and so on, and then the models in each specific language are generated from those `.proto` files.

For us, there is a big problem with that approach: **code generated is not idiomatic** for any of the languages (take a look at the python code generated by any proto file and you will understand why).

Instead of following this method, we thought of something else: choose the language with the bigger role in our codebase and use it as the source of truth, instead. That way, at least one of the language has idiomatic models and code. This language for us is Go.

## Proteus

Because of the aforementioned reason, we started working on [proteus](https://github.com/src-d/proteus), a tool that scans Go packages and generates `.proto` files from them.

**How does it work?**

* Scans all structs that have the comment `//proteus:generate` and generates them as protobuf messages.
* Scans all the type definitions with the comment `//proteus:generate` and their constant values and transforms them into proper protobuf enumerations.
* Resolves the types and ignores those which it can't.
* Converts it to protobuf structures and writes the `.proto` files.

So, imagine you have the following code:

```go
package models

import "time"

type Model struct {
        ID        int64
        CreatedAt time.Time
}

//proteus:generate
type User struct {
        Model
        Status             Status
        Username           string
        Password           string
        NotCryptedPassword string `proteus:"-"`
}

//proteus:generate
type Status int

const (
        Pending  Status = iota
        Active
        Inactive
)
```

That code will become the following protobuf file:

```proto
syntax = "proto3";
package models;

import "google/protobuf/timestamp.proto";

option go_package = "models";

message User {
        option (gogoproto.typedecl) = false;
        int64 id = 1 [(gogoproto.customname) = "ID"];
        google.protobuf.Timestamp created_at = 2 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
        models.Status status = 3;
        string username = 4;
        string password = 5;
}

enum Status {
        option (gogoproto.enumdecl) = false;
        option (gogoproto.goproto_enum_prefix) = false;
        PENDING = 0 [(gogoproto.enumvalue_customname) = "Pending"];
        ACTIVE = 1 [(gogoproto.enumvalue_customname) = "Active"];
        INACTIVE = 2 [(gogoproto.enumvalue_customname) = "Inactive"];
}
```

You can check for a more detailed example in the [examples folder](https://github.com/src-d/proteus/tree/master/example).

## gRPC service generation

Methods and functions with the comment `//proteus:generate` will be exported as a gRPC service. Those methods and functions will be `rpc`s in the service. Proteus also generates the implementation of the server that satisfies the interface defined by protobuf for that service.

To put you in context, the complete generation process of proteus consists of three steps:

* Generate a `.proto` file from your Go source code.
* Use `protoc` and `gogo/protobuf` to generate the missing protobuf-related bits for your Go source code (marshal, unmarshal, etc) as well as defining a client and a server interface for your RPC services. Note that `gogo/protobuf` and `protoc` **do not** generate an implementation for the RPC service server.
* Generate the implementation of the RPC service server using some conventions to make this actually possible.

Imagine the following code:

```go
package user

//proteus:generate
func (s *UserStore) GetByID(id uint64) (*User, error) {
        // implementation
}
```

This would generate the following protobuf source:

```proto
service UserService {
        rpc UserStore_GetByID(UserStore_GetByIDRequest) returns (User);
}
```

Which would generate the following implementation:


```go
type userServiceServer struct {
}

func NewUserServiceServer() *userServiceServer {
        return &userServiceServer{}
}

func (s *userServiceServer) UserStore_GetByID(ctx context.Context, in *UserStore_GetByIDRequest) (result *User, err error) {
        result, err = s.UserStore.GetByID(in.Arg1)
        return
}
```

The above code does not work, obviously. But it's impossible for proteus to know how to find the instance of `UserStore` to invoke the method `GetByID`, that's why the convention is to look for a field in the `userServiceServer` struct with the same name as the receiver type of the method. proteus can only generate a default implementation of that, but if the implementation is provided by you, it will use yours instead.

```go
type userServiceServer struct {
        *UserStore
}

func NewUserServiceServer() *userServiceServer {
        return &userServiceServer{NewUserStore()}
}
```

If we implement the type ourselves, the generated code will be just the method, and `UserStore_GetByID` would work, making everything function as we expect.

## Integration with `gogo/protobuf`

Because the whole generation process consists of three steps, as explained in the previous section, proteus has a shorthand for running all three of them in one single command directly built into the proteus binary.

```
proteus -p my/go/package 
        -p my/other/go/package 
        -f path/to/my/protos/folder
        --verbose
```

This command generates your protos from your Go source code, the marshal/unmarshal for your structs and the implementation of your RPC services without you having to take a look at any protobuffer code.

For this command to work we need two dependencies installed:

* [`protoc`](https://github.com/google/protobuf) command
* `go get github.com/gogo/protobuf/...`

## Why not drop the need for `gogo/protobuf`?

`gogo/protobuf` works in another completely different domain. While `gogo/protobuf` works from `Proto -> Go`, proteus works in the opposite direction.

The only thing we are implementing in proteus is what we think is missing: keeping Go as a source of truth for messages, enumerations and services.

Yes, it introduces two steps instead of just one. But it has several advantages.

## Conclusion

We are trying to keep Go as the source of truth.
* We want to use our code ourselves, totally abstracted from protobuf.
* We don't want to write by ourselves the gRPC server that satisfies the generated interface.
